#! /usr/bin/python
# -*- Python -*-

"""HG ALSA Tool

Do operations on ALSA GIT repositories.

Usage:
	%(PROGRAM)s [options] command
"""

import os
import sys
import getopt
from shutil import rmtree, copyfile

VERSION="2.0"

PROGRAM = sys.argv[0]
ROOT = os.path.abspath(os.getcwd())
USER = os.getenv('USER')
VERBOSE = False
REPOSITORIES = [
        'alsa', 'alsa-driver', 'alsa-kmirror', 'alsa-lib', 'alsa-utils',
        'alsa-tools', 'alsa-firmware', 'alsa-oss', 'alsa-plugins',
        'alsa-python'
]        

def eprint(msg):
        sys.stderr.write(msg + '\n')

def selectrepos(repos):
        if repos == None or len(repos) == 0:
                return REPOSITORIES[:]
        else:
        	neg = repos[0][0] == '-'
        	for repo in repos:
        		if (neg and repo[0] != '-') or \
        		   (not neg and repo[0] == '-'):
        			raise ValueError, "inverted and non-inverted repo specifications cannot be mixed!"
		if neg:
			res = REPOSITORIES
			for repo in repos:
				res.remove(repo[1:])
			return res
		for repo in repos:
			if not repo in REPOSITORIES:
				raise ValueError, "repository '%s' is unknown" % repo
                return repos

def xlist(argv=None):
	s = ''
	for i in REPOSITORIES:
		s += i + ' '
	print s[:-1]

def git(repo):
	dir = ROOT + '/' + repo
	return "git --work-tree=%s --git-dir=%s" % (dir, dir + '/.git')

def clone(argv=None):
        repos = selectrepos(argv)
        for repo in repos:
        	print "clone", repo

def diff(argv=None):
        repos = selectrepos(argv)
	for repo in repos:
		pull([repo])
		if os.system("%s --no-pager diff origin/master..master" % git(repo)):
			raise ValueError, "diff %s" % repo

def pull(argv=None):
        repos = selectrepos(argv)
	for repo in repos:
		if os.system("%s checkout master" % git(repo)):
			raise ValueError, "checkout %s" % repo
		os.chdir(ROOT + '/' + repo)
		if os.system("%s pull" % git(repo)):
			raise ValueError, "pull %s" % repo

def push(argv=None):
        repos = selectrepos(argv)
	for repo in repos:
		if os.system("%s checkout master" % git(repo)):
			raise ValueError, "checkout %s" % repo
		if os.system("%s push master:refs/heads/master" % git(repo)):
			raise ValueError, "push %s" % repo

def version_sort(tags):
	tags1 = []
	tags2 = {}
	for tag in tags:
		tag = tag.strip()
		if tag == "tip":
			continue
		try:
			a, b, c = tag.split('.')
			if a[0] != 'v':
				raise ValueError
			a = int(a[1:])
			b = int(b)
			idx = 0
			while idx < len(c) and ord(c[idx]) <= ord('9'):
				idx += 1
			c1 = int(c[:idx])
			c2 = c[idx:]
			str = "%08i.%08i.%08i.%s" % (a, b, c1, c2)
			tags1.append(str)
			tags2[str] = tag
		except:
			from traceback import print_exc
			print_exc()
			pass
	tags1.sort()
	res = []
	for tag in tags1:
		res.append(tags2[tag])
	if len(res) > 0:
		return res
	return None

def showchanges1(repos):
	res = {}
	for repo in repos:
		if repo == 'alsa':
			continue
		res[repo] = []
		tags = version_sort(os.popen("%s tag" % git(repo)).readlines())
		if not tags:
			raise ValueError, "cannot obtain tags for repo %s" % repo
		fp = os.popen("%s diff --stat %s..HEAD" % (git(repo), tags[-1]))
		while 1:
			line = fp.readline()
			if not line or line.find('|') <= 0:
				break
			a, b = line.split('|')
			a = a.strip()
			if a in ['.hgignore', '.hgtags']:
				continue
			if a.endswith('.gitignore'):
				continue
			if VERBOSE:
				print ' ', line.strip()
			res[repo].append(a)
		del fp
	return res

def showchanged(argv=None):
        if argv == None:
        	tag = "last"
        	repos = selectrepos(None)
	else:
        	tag = argv[0]
	        repos = selectrepos(argv[1:])
	res = showchanges1(repos)
	for repo in res:
		print 'Repository %s has %s changed files' % (repo, len(res[repo]))
		if VERBOSE:
			print ' ', line.strip()

def release1(repo, tag):
	print
	print 'Repository %s' % repo
	print ''.rjust(11 + len(repo), '*')
	version = tag[1:]
	pull([repo])
	if repo == 'alsa-driver':
		pull(['alsa-kmirror'])
	if repo == 'alsa-driver':
		lines = open(ROOT + '/' + repo + '/configure.in').readlines()
		for idx in range(0, len(lines)):
			if lines[idx].startswith('CONFIG_SND_VERSION="'):
				lines[idx] = 'CONFIG_SND_VERSION="%s"\n' % version
				print lines[idx][:-1]
				break
		open(ROOT + '/' + repo + '/configure.in', "w+").write(''.join(lines))
		os.chdir(ROOT + '/' + repo)
		if os.path.exists('include/version.h'):
			os.remove('include/version.h')
		if os.path.exists('alsa-kernel/include/version.h'):
			os.remove('alsa-kernel/include/version.h')
		if os.system("make ALSAKERNELDIR=../alsa-kernel all-deps"):
			raise ValueError, "make"
		if os.system("aclocal"):
			raise ValueError, "aclocal"
		if os.system("autoconf"):
			raise ValueError, "autoconf"
		if os.system("./configure --with-debug=full --with-isapnp=yes --with-sequencer=yes --with-kernel=%s" % (ROOT + '/alsa-kernel')):
			raise ValueError, "configure"
		if os.system("make include/sound/version.h"):
			raise ValueError, "include/sound/version.h"
	elif repo in ['alsa-lib', 'alsa-plugins', 'alsa-utils',
		      'alsa-firmware', 'alsa-oss']:
		lines = open(ROOT + '/' + repo + '/configure.in').readlines()
		for idx in range(0, len(lines)):
			if lines[idx].startswith('AM_INIT_AUTOMAKE(%s, ' % repo):
				lines[idx] = 'AM_INIT_AUTOMAKE(%s, %s)"\n' % (repo, version)
				print lines[idx][:-1]
				break
		open(ROOT + '/' + repo + '/configure.in', "w+").write(''.join(lines))
	elif repo == 'alsa-tools':
		lines = open(ROOT + '/' + repo + '/Makefile').readlines()
		for idx in range(0, len(lines)):
			if lines[idx].startswith("VERSION = "):
				lines[idx] = "VERSION = %s\n" % version
				print lines[idx][:-1]
				break
		open(ROOT + '/' + repo + '/Makefile', "w+").write(''.join(lines))
	elif repo == 'alsa-python':
		lines = open(ROOT + '/' + repo + '/setup.py').readlines()
		for idx in range(0, len(lines)):
			if lines[idx].startswith("VERSION='"):
				lines[idx] = "VERSION='%s'\n" % version
				print lines[idx][:-1]
				break
		open(ROOT + '/' + repo + '/setup.py', "w+").write(''.join(lines))
		lines = open(ROOT + '/' + repo + '/PKG-INFO').readlines()
		for idx in range(0, len(lines)):
			if lines[idx].startswith("Version: "):
				lines[idx] = "Version: %s\n" % version
				print lines[idx][:-1]
				break
		open(ROOT + '/' + repo + '/PKG-INFO', "w+").write(''.join(lines))

def release(argv):
	if argv == None or argv[0][0] != 'v':
		raise ValueError, "specify release version in tag form"
	tag = argv[0]
	argv = argv[1:]
	if len(argv) == 0:
		repos = selectrepos(None)
	elif argv[0] == 'auto':
		res = showchanges1(selectrepos(None))
		repos = res.keys()
	else:
		repos = selectrepos(argv)
	if 'alsa' in repos:
		repos.remove('alsa')
	if 'alsa-kmirror' in repos:
		repos.remove('alsa-kmirror')
	print 'Doing release for: %s' % ','.join(repos)
	for repo in repos:
		release1(repo, tag)

def changes(argv):
        
	def rev_to_dot(rev):
        	if rev[0] == 'v':
                	return rev[1:]
	        else:
        	        return rev

	def print_underline(c, str):
	        i = len(str)
	        while i > 0:
	        	sys.stdout.write(c)
	        	i -= 1
		print

        def store_changes(changes, logs, module, xrev):
	        if module == 'alsa-kernel':
		        module = 'alsa-driver'
                for a in logs:
                        if a.has_key('branch'):
                                return
	        	already = False
	        	idx1 = 0
	        	for change in changes:
	        		if a['user'] == change['user'] and \
	        		   a['description'] == change['description']:
	        			# print 'SAME!!!'
	        			already = True
	        			break
	        		if a['date'] < change['date']:
	        		        a['xrev'] = xrev
	        		        a['module'] = module
	        			changes.insert(idx1, a)
	        			# print 'INSERTED!!!'
	        			already = True
	        			break
	        		idx1 += 1
	        	if not already:
		                a['xrev'] = xrev
		                a['module'] = module
		                changes.append(a)

        def merge_members(changes):
	        global GERRORS

        	res = {}
        	try:
		        os.remove("/tmp/changes-log.txt")
        	except OSError:
	        	pass
                for change in changes:
		        module = change['module']
		        if not res.has_key(module):
			        res[module] = {}
                        members = cvsps_merge_members(change['files'], module)
                        if len(members) == 0:
			        continue
        		members = members[0]
	        	mems = string.split(members, ',')
	        	for mem in mems:
			        if mem == 'IGNORE':
				        continue
				if not res[module].has_key(mem):
				        res[module][mem] = []
                                res[module][mem].append(change)
                        if GERRORS > 0:
                                print 'Bailing out...'
                                sys.exit(1);
        	return res

        def get_items(allitems):
        	items = []
        	idx = 0
        	for item in ['Sound Core', 'ALSA Core']:
        		items.append([item])
        		idx += 1
        	core = idx
        	items.append([])	# Core
        	midlevel = idx + 1
        	items.append([])	# Midlevel
        	all = idx + 2
        	items.append(allitems)
        	items[all].sort()
        	for item in items[all]:
        		if string.find(item, 'Core') >= 0:
        			items[core].append(item)
        		if string.find(item, 'Midlevel') >= 0:
        			items[midlevel].append(item)
        		if string.find(item, 'API') >= 0:
        			items[midlevel].append(item)
        	idx1 = core
        	while idx1 < all:
        		for item in items[idx1]:
        			items[all].remove(item)
        		idx1 += 1
        	for items1 in items[:idx]:
        		for item in items1:
        			idx1 = idx
        			while idx1 < len(items):
        				if item in items[idx1]:
        					items[idx1].remove(item)
        				idx1 += 1
        	return items

        def check_tag(tags, rev):
                for tag in tags:
                        a = tag[41:-1]
                        if len(a) != len(rev):
                                continue
                        if a == rev:
                                return True
                return False

	try:
		rev1 = argv[0]
		rev2 = argv[1]
	except:
		sys.stderr.write('Please, specify oldtag and newtag\n')
		sys.exit(1)

	changes = []
	fullset = REPOSITORIES
	fromrev = {}
	for module in fullset:
		xrev = rev1
		fp = os.popen("%s tag" % git(module))
		tags = fp.readlines()
		fp.close()
		if not check_tag(tags, rev2):
		        continue
                tags1 = []
                base = rev2
                while not check_tag(tags, xrev):
                        if rev2[-3:-1] == "rc":
                                base = rev2[:-3]
                        elif rev2[-1:] >= "a":
                                base = rev2[:-1]
                        for tag in tags:
                                a = tag[41:-1].strip()
				if a >= rev2:
					continue
				tags1.append(tag[40:-1].strip())
                        tags1 = version_sort(tags1)
                        if len(tags1) != 0:
                                xrev = tags1[len(tags1)-1]
                                break
                        major, minor, subminor = base.split('.')
                        subminor = int(subminor) - 1
                        if subminor < 0:
                                raise ValueError
                        base = "%s.%s.%s" % (major, minor, subminor)
		fromrev[module] = xrev
		lines = my_popen("hg log -r %s:%s -v" % (xrev, rev2))
		store_changes(changes, parse_hg_log(lines, module), module, xrev)
	res = merge_members(changes)
	modules1 = res.keys()
	modules = []
	groups = {}
	for module in fullset:
		if module in modules1:
			modules.append(module)
			rev = fromrev[module]
			if not groups.has_key(rev):
				groups[rev] = []
			groups[rev].append(module)
	print '{| align="right"\n| __TOC__\n|}'
	for rev in groups:
		str = '=Changelog between %s and %s releases=' % (rev_to_dot(rev), rev_to_dot(rev2))
		print str
		for module in groups[rev]:
			print '==%s==' % module
			items = get_items(res[module].keys())
			for items1 in items:
				for b in items1:
					if not res[module].has_key(b):
						continue
					print '===%s===' % b
					for a in res[module][b]:
						log = a['description'][0]
						if log[:9] == 'Summary: ':
							log = log[9:]
						elif log[:8] == 'Summary:':
							log = log[8:]
						print ': %s' % log[:-1]
	for rev in groups:
		str = '=Detailed changelog between %s and %s releases=' % (rev_to_dot(rev), rev_to_dot(rev2))
		print str
		for module in groups[rev]:
			print '==%s==' % module
			items = get_items(res[module].keys())
			for items1 in items:
				for b in items1:
					if not res[module].has_key(b):
						continue
					print '===%s===' % b
					for a in res[module][b]:
						log = a['description']
						first = "-"
						for l in log:
							if l[:13] == "Patch-level: ":
								continue
							if l[:13] == "Patch-Level: ":
								continue
							print ': %s %s' % (first, l[:-1])
							first = " "

def usage(code=0, msg=''):
        print __doc__ % globals()
        print 'Where options is:'
        for opt in OPTS:
                print
                print "\t-%s %s" % (opt[0].replace(':', ''), opt[3])
                print "\t--%s %s" % (opt[1].replace('=', ''), opt[3])
                print "\t\t%s" % opt[4]
        print
        print 'Where command is:'
        for cmd in CMDS:
                print
                print "\t%s %s" % (cmd[0], cmd[2])
                print "\t\t%s" % cmd[3]
        if msg:
                print
                print msg
        sys.exit(code)

def root(argv):
	global ROOT
        if argv == None:
                eprint('Specify root directory.')
                sys.exit(1)
        ROOT=os.path.abspath(argv[0])

def verbose(argv):
	global VERBOSE
	VERBOSE=True

def extpick(argv, edit=False):
	repo = os.path.abspath(argv[0])
	commit = argv[1]
	tmpdir = ".extpick"
	if not os.path.exists(tmpdir):
		os.mkdir(tmpdir)
	if os.system("git --work-tree=%s --git-dir=%s format-patch -k --stdout --full-index --committer %s~1..%s > %s" % (repo, repo + '/.git', commit, commit, tmpdir + '/format-patch')):
		raise ValueError, "format-patch"
	lines = open(tmpdir + "/format-patch").readlines()
	for idx in range(0, len(lines)):
		if lines[idx].startswith('Subject: '):
			a = lines[idx][8:].strip()
			if not a.upper().startswith('[ALSA]') and \
			   not a.upper().startswith('ALSA:') and \
			   not a.upper().startswith('[SOUND]') and \
			   not a.upper().startswith('SOUND:'):
			   	if a.upper().startswith('SOUNDS: '):
			   		a = a[8:].strip()
				lines[idx] = 'Subject: sound: ' + a + '\n'
				print repr(lines[idx])
			break
	open(tmpdir + "/format-patch", "w+").write(''.join(lines))
	if edit:
		editor = os.environ.has_key('EDITOR') and os.environ['EDITOR'] or 'vi'
		copyfile(tmpdir + "/format-patch", tmpdir + "/format-patch.orig")
		os.system("%s %s" % (editor, tmpdir + "/format-patch"))
		if not os.system("diff %s %s > /dev/null" % (tmpdir + "/format-patch", tmpdir + "/format-patch.orig")):
			return "nochanges"
	res = os.system("git am --committer -i -3 --keep %s" % (tmpdir + '/format-patch'))
	#if os.system("git --work-tree=%s --git-dir=%s mailinfo -u %s %s < %s > %s" % (repo, repo + '/.git', tmpdir + '/msg', tmpdir + '/patch', tmpdir + '/format-patch', tmpdir + '/info')):
	#	raise ValueError, "mail-info"
	rmtree(tmpdir)
	return res

def edit(argv, remove=False):
	commit = argv[0]
	fp = os.popen("git log --pretty=oneline --reverse %s~1..HEAD" % commit)
	commits = []
	tmpdir = ".editmsg"
	if not os.path.exists(tmpdir):
		os.mkdir(tmpdir)
	while 1:
		line = fp.readline()
		if not line:
			break
		commits.append(line.split(' ')[0])
	open(tmpdir + '/commits', "w+").write('\n'.join(commits))
	head = os.popen("git rev-parse HEAD").readline().strip()
	print "Original HEAD is %s..." % head
	print "Removed commits are in %s..." % tmpdir + '/commits'
	print "Resetting tree to %s..." % os.popen("git log --pretty=oneline %s~1..%s" % (commit, commit)).readline().strip()
	if os.system("git-reset --hard %s~1" % commit):
		raise ValueError, "git-reset"
	first = True
	for commit in commits:
		if remove and first:
			first = False
			continue
		res = extpick(['.', commit], edit=first)
		if type(res) == type('') and res == "nochanges":
			print "No changes, resetting back to %s..." % head
			sys.exit(os.system("git reset --hard %s" % head))
		if res:
			sys.stderr.write("Error, bailing out\n")
			sys.exit(1)
		first = False
	rmtree(tmpdir)

def remove(argv):
	edit(argv, remove=True)

OPTS=[
        ['h', 'help', usage, '', 'Print this help'],
        ['r', 'root', root, '<GIT root dir>', 'Set GIT root directory (default is %s)' % ROOT],
        ['v', 'verbose', verbose, '', 'Set verbose mode']
]
CMDS=[
	['list', xlist, '', 'Show ALSA repository names'],
        ['clone', clone, '[repo]', 'Clone all (default) or selected repositories'],
        ['diff', diff, '[repo]', 'Do diff on selected or all (default) repositories'],
        ['pull', pull, '[repo]', 'Do pull on selected or all (default) repositories'],
        ['push', push, '[repo]', 'Do push on selected or all (default) repositories'],
        ['showchanged', showchanged, 'tag [repo]', 'Show which repositories were changed since tag'],
        ['release', release, 'tag [repo]', 'Do an ALSA release (auto = automatic change control)'],
        ['changes', changes, 'oldtag newtag', 'Show changes between oldtag and newtag'],
        ['extpick', extpick, 'local-repo-path commit', 'Pick and merge a patch from another repository'],
        ['edit', edit, 'commit', 'Edit a message for commit'],
        ['remove', remove, 'commit', 'Remove a commit']
]
 
def main():
	global ROOT
	if os.path.exists(ROOT + '/../alsa-kernel'):
		ROOT = os.path.abspath(ROOT + '/..')
        opts = ''
        lopts = []
        for opt in OPTS:
              opts += opt[0]
              lopt = opt[1]
              if opt[3] != '':
                      opts += ':'
                      lopt += '='
              lopts.append(lopt)
        try:
              opts, args = getopt.getopt(sys.argv[1:], opts, lopts)
        except getopt.error, msg:
                    usage(1, msg)
        for opt, arg in opts:
                for xopt in OPTS:
                        if opt in ("-" + xopt[0], "-" + xopt[1]):
                                xopt[2](arg)
        if not args:
              eprint("Command not specified, for help type '%s -h'" % PROGRAM[PROGRAM.rfind('/')+1:])
              sys.exit(1)
        for cmd in CMDS:
              if cmd[0] == args[0]:
                    if len(args) < 2:
                          cmd[1]()
                    else:
                          cmd[1](args[1:])
                    sys.exit(0)
        usage(1, 'Unknown command "%s"' % args[0])

if __name__ == '__main__':
        main()
        sys.exit(0)
